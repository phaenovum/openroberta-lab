include: "classpath:/helperMethodsCommon.yml"
# method names are based on FunctionNames and EdisonUsedHardwareCollectorVisitor.Method
# languages are based on HelperMethodGenerator.Language

## FunctionNames

PRIME:
  PYTHON: |
    def _isPrime(num):
        if num <= 1: return False
        newNum = num - 2
        for x in range(newNum):
            y = (x + 2)
            if (num % y) == 0: return False
        return True

# not prefixed with _ because many super methods generate the standard python sum/min/max which would have to be overridden
MIN:
  PYTHON: |
    def min(list):
        listMin = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] < listMin:
                listMin = list[i]
        return listMin
MAX:
  PYTHON: |
    def max(list):
        listMax = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] > listMax:
                listMax = list[i]
        return listMax
SUM:
  PYTHON: |
    def sum(list):
        listSum = 0
        listLength = len(list)
        for i in range(listLength): listSum = (listSum + list[i])
        return listSum

ABS:
  PYTHON: |
    def _abs(num):
        if (num < 0): return -num
        else: return num
# this is also used by POW10
POWER:
  PYTHON: |
    def _pow(base, exp):
        result = 1
        b = base
        for _ in range(exp):
            result *= b
        return result

## EdisonUsedHardwareCollectorVisitor.Method

OBSTACLEDETECTION:
  PYTHON: |
      def _obstacleDetection(mode):
          global obstacleDetectionOn
          if (obstacleDetectionOn == False):
              Ed.ObstacleDetectionBeam(Ed.ON)
              obstacleDetectionOn = True
          return Ed.ReadObstacleDetection() == mode

IRSEND:
  PYTHON: |
      def _irSend(payload):
          global obstacleDetectionOn
          if (obstacleDetectionOn == True):
              Ed.ObstacleDetectionBeam(Ed.OFF)
              obstacleDetectionOn = False
          Ed.SendIRData(payload)

# mode: 0 = edison IR data; 1 = remote control data
IRSEEK:
  PYTHON: |
      def _irSeek(mode):
          global obstacleDetectionOn
          if (obstacleDetectionOn == True):
              Ed.ObstacleDetectionBeam(Ed.OFF)
              obstacleDetectionOn = False
          if (mode == 0): return Ed.ReadIRData()
          elif (mode == 1): return Ed.ReadRemote()

# motor: 0 = LMOTOR; 1 = RMOTOR
# distance: Entweder integer oder Ed.DISTANCE_UNLIMITED
MOTORON:
  PYTHON: |
      def _motorOn(motor, power, distance):
          if (motor == 0):
              if (power < 0): Ed.DriveLeftMotor(Ed.BACKWARD, -_shorten(power), distance)
              else: Ed.DriveLeftMotor(Ed.FORWARD, _shorten(power), distance)
          if (motor == 1):
              if (power < 0): Ed.DriveRightMotor(Ed.BACKWARD, -_shorten(power), distance)
              else: Ed.DriveRightMotor(Ed.FORWARD, _shorten(power), distance)

READDIST:
  PYTHON: |
      def _readDist(leftSpeed, rightSpeed):
          if (leftSpeed > rightSpeed):
              return Ed.ReadDistance(Ed.MOTOR_LEFT)
          else:
              return Ed.ReadDistance(Ed.MOTOR_RIGHT)

CURVE:
  PYTHON: |
      def _diffCurve(direction, leftSpeed, rightSpeed, distance):
          Ed.Drive(Ed.FORWARD, _shorten(30), Ed.DISTANCE_UNLIMITED)
          Ed.DriveLeftMotor(Ed.FORWARD, _shorten(10), Ed.DISTANCE_UNLIMITED)
          Ed.DriveRightMotor(Ed.FORWARD, _shorten(30), Ed.DISTANCE_UNLIMITED)
          Ed.SetDistance(Ed.MOTOR_LEFT, 20)
          Ed.SetDistance(Ed.MOTOR_RIGHT, 20)
          while _readDist(10, 30) > 0:
              pass
          Ed.ResetDistance()

DIFFDRIVE:
  PYTHON: |
      def _diffDrive(direction, speed, distance):
          if speed < 0:
              speed = -speed
              if direction == Ed.FORWARD: Ed.Drive(Ed.BACKWARD, _shorten(speed), distance)
              else: Ed.Drive(Ed.FORWARD, _shorten(speed), distance)
          else: Ed.Drive(direction, _shorten(speed), distance)

DIFFTURN:
  PYTHON: |
      def _diffTurn(direction, speed, degree):
          if speed < 0:
              speed = -speed
              if direction == Ed.SPIN_RIGHT: Ed.Drive(Ed.SPIN_LEFT, _shorten(speed), degree)
              else: Ed.Drive(Ed.SPIN_RIGHT, _shorten(speed), degree)
          else: Ed.Drive(direction, _shorten(speed), degree)
    
SHORTEN:
  PYTHON: |
      def _shorten(num): return ((num+5)/10)
