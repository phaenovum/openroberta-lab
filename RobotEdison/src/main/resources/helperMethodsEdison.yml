include: "classpath:/helperMethodsCommon.yml"
# method names are based on FunctionNames and EdisonUsedHardwareCollectorVisitor.Method
# languages are based on HelperMethodGenerator.Language

# FunctionNames

PRIME:
  PYTHON: |
    def _isPrime(number):
        if number <= 1: return False
        newNum = number - 2
        for x in range(newNum):
            y = (x + 2)
            if (number % y) == 0: return False
        return True
MIN:
  PYTHON: |
    def min(list):
        min_of_list = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] < min_of_list:
                min_of_list = list[i]
        return min_of_list
MAX:
  PYTHON: |
    def max(list):
        max_of_list = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] > max_of_list:
                max_of_list = list[i]
        return max_of_list
SUM:
  PYTHON: |
    def sum(list):
        sum_of_list = 0
        listLength = len(list)
        for i in range(listLength): sum_of_list = (sum_of_list + list[i])
        return sum_of_list
LISTS_REPEAT:
  PYTHON: |
    def _create_repeat(item, times):
        list = Ed.List(times)
        listLength = len(list)
        for i in range(listLength): list[i] = item
        return list
ABS:
  PYTHON: |
    def _abs(num):
        if (num<0): return -num
        else: return num
# this is also used by POW10
POWER:
  PYTHON: |
    def _pow(base, exp):
        result = 1
        b = base
        for _ in range(exp):
            result *= b
        return result

# EdisonUsedHardwareCollectorVisitor.Method

OBSTACLEDETECTION:
  PYTHON: |
      def obstacle_detection(mode):
          global obstacleDetectionOn
          if (obstacleDetectionOn == False):
              Ed.ObstacleDetectionBeam(Ed.ON)
              obstacleDetectionOn = True
          return Ed.ReadObstacleDetection() == mode

IRSEND:
  PYTHON: |
      def ir_send(payload):
          global obstacleDetectionOn
          if (obstacleDetectionOn == True):
              Ed.ObstacleDetectionBeam(Ed.OFF)
              obstacleDetectionOn = False
          Ed.SendIRData(payload)

# mode: 0 = edison IR data; 1 = remote control data
IRSEEK:
  PYTHON: |
      def ir_seek(mode):
          global obstacleDetectionOn
          if (obstacleDetectionOn == True):
              Ed.ObstacleDetectionBeam(Ed.OFF)
              obstacleDetectionOn = False
          if (mode == 0): return Ed.ReadIRData()
          elif (mode == 1): return Ed.ReadRemote()

# motor: 0 = LMOTOR; 1 = RMOTOR
# distance: Entweder integer oder Ed.DISTANCE_UNLIMITED
MOTORON:
  PYTHON: |
      def motor_on(motor, power, distance):
          if (motor == 0):
              if (power < 0): Ed.DriveLeftMotor(Ed.BACKWARD, -shorten(power), distance)
              else: Ed.DriveLeftMotor(Ed.FORWARD, shorten(power), distance)
          if (motor == 1):
              if (power < 0): Ed.DriveRightMotor(Ed.BACKWARD, -shorten(power), distance)
              else: Ed.DriveRightMotor(Ed.FORWARD, shorten(power), distance)

CURVE:
  PYTHON: |
      def read_dist(leftspeed, rightspeed):
          if (leftspeed > rightspeed):
              return Ed.ReadDistance(Ed.MOTOR_LEFT)
          else:
              return Ed.ReadDistance(Ed.MOTOR_RIGHT)

DIFFDRIVE:
  PYTHON: |
      def diff_drive(direction, speed, distance):
          if speed < 0:
              speed = -speed
              if direction == Ed.FORWARD: Ed.Drive(Ed.BACKWARD, shorten(speed), distance)
              else: Ed.Drive(Ed.FORWARD, shorten(speed), distance)
          else: Ed.Drive(direction, shorten(speed), distance)

DIFFTURN:
  PYTHON: |
      def diff_turn(direction, speed, degree):
          if speed < 0:
              speed = -speed
              if direction == Ed.SPIN_RIGHT: Ed.Drive(Ed.SPIN_LEFT, shorten(speed), degree)
              else: Ed.Drive(Ed.SPIN_RIGHT, shorten(speed), degree)
          else: Ed.Drive(direction, shorten(speed), degree)
